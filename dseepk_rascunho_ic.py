# -*- coding: utf-8 -*-
"""DSeePK_rascunho_iC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hEZh0jh_MBbZkyt20hJ_7Ivd132lKlkc

Abaixo está a célula única revisada, incorporando todas as correções e melhorias discutidas, com comentários detalhados. Ela pode ser executada no Google Colab em modo simulação (SIMULATE = True) e, quando levada para o laboratório, basta alterar para False e garantir que as dependências estejam instaladas.

#Principais melhorias implementadas:
1. Correção de backlash do monocromador:

O método mover_para agora verifica a direção do movimento. Quando o próximo comprimento de onda é menor que o atual, ele executa um overshoot (2 nm abaixo) e depois retorna ao alvo, garantindo que a aproximação final seja sempre no sentido crescente, conforme recomendação do manual.

2. Configuração completa do lock-in:

O método configurar aceita parâmetros claros para modo de referência, harmônico, tipo de entrada, acoplamento, etc., e envia os comandos apropriados (em ponto flutuante quando possível).

A constante de tempo é definida diretamente em segundos com TC., evitando índices confusos.

3. Auto-sensibilidade dinâmica:

A função auto_sensitivity() executa o comando AS do lock-in e lê a nova sensibilidade.

Durante a varredura, se o status indicar overload, o programa chama auto_sensitivity() e aguarda a estabilização antes de continuar.

4. Verificação de status:

A função verificar_status() interpreta o byte de status, detectando overload e unlock. Isso permite decisões inteligentes durante a aquisição.

5. Documentação e comentários:

Cada bloco de código é comentado, explicando o propósito e as escolhas de implementação.

Esta versão está pronta para simulação no Colab e, quando migrada para o laboratório, exigirá apenas a instalação das bibliotecas pyvisa e o acesso à DLL da Bentham, além de ajustes nos endereços e caminhos.
"""

# ============================================================
# SISTEMA COMPLETO: MONOCROMADOR + LOCK-IN
# Versão Aprimorada para Google Colab (Modo Simulação)
# Inclui:
#   - Correção de backlash do monocromador
#   - Configuração completa do lock-in (modos, referência, auto-sensibilidade)
#   - Uso de comandos em ponto flutuante para precisão
#   - Verificação de status e tratamento básico de erros
# ============================================================

import time
import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# ============================================================
# CONFIGURAÇÃO GLOBAL
# ============================================================

SIMULATE = True   # Mude para False no laboratório

# Parâmetros da varredura
LAMBDA_START = 400    # nm
LAMBDA_END   = 800    # nm
STEP         = 2      # nm

# Parâmetros do lock-in
TAU = 0.3             # constante de tempo desejada (segundos)
WAIT_FACTOR = 5       # tempo de espera = TAU * WAIT_FACTOR (5x é seguro)

# ============================================================
# DRIVER DO MONOCROMADOR (com correção de backlash)
# ============================================================

class BenthamMonochromator:
    def __init__(self):
        self.current_lambda = None   # último comprimento de onda definido (nm)
        self.last_direction = None   # 'up' ou 'down' para controle de backlash

    def inicializar(self):
        if SIMULATE:
            print("Monocromador (simulado) inicializado.")
        else:
            import ctypes
            dll_path = "C:/Bentham/SDK/benhw64.dll"
            self.lib = ctypes.cdll.LoadLibrary(dll_path)

            if self.lib.BI_initialise() != 0:
                raise RuntimeError("Erro ao inicializar Bentham")

            if self.lib.BI_build_system(b"system.cfg", 0) != 0:
                raise RuntimeError("Erro ao carregar configuração")
            # Assume-se que a configuração já contém os parâmetros das grades (ZORD, alpha)

    def mover_para(self, lambda_nm):
        """
        Move o monocromador para o comprimento de onda desejado,
        aplicando correção de backlash: sempre aproxima vindo de valores menores.
        """
        if SIMULATE:
            self.current_lambda = lambda_nm
            return lambda_nm

        # Define um overshoot de 2 nm para compensar o backlash (valor empírico)
        OVERSHOOT = 2.0  # nm

        # Se for o primeiro movimento, apenas posiciona
        if self.current_lambda is None:
            wl_alvo = lambda_nm
            direcao = 'up' if lambda_nm >= 0 else 'down'  # irrelevante
        else:
            # Verifica se a direção mudou
            if lambda_nm > self.current_lambda:
                direcao = 'up'
            elif lambda_nm < self.current_lambda:
                direcao = 'down'
            else:
                # Mesmo comprimento, não faz nada
                return lambda_nm

            # Se a direção for 'down', precisamos ir além e voltar
            if direcao == 'down':
                # Vai para um valor menor (lambda_nm - overshoot) e depois sobe para lambda_nm
                temp = lambda_nm - OVERSHOOT
                # Garante que não seja negativo
                if temp < 0:
                    temp = 0
                # Move para o ponto temporário
                self._comando_mover(temp)
                # Agora sobe para o alvo
                self._comando_mover(lambda_nm)
            else:
                # Direção 'up' ou primeiro movimento: move direto
                self._comando_mover(lambda_nm)

        self.current_lambda = lambda_nm
        return lambda_nm

    def _comando_mover(self, wl):
        """Método interno para enviar comando real ao hardware."""
        import ctypes
        wl_req = ctypes.c_double(wl)
        wl_real = ctypes.c_double()
        self.lib.BI_select_wavelength(wl_req, ctypes.byref(wl_real))
        # Poderia retornar wl_real para maior precisão, mas simplificamos
        return wl_real.value

    def fechar(self):
        if not SIMULATE:
            self.lib.BI_park()
            self.lib.BI_close_system()
        print("Monocromador fechado.")

# ============================================================
# DRIVER DO LOCK-IN SR7265 (com configuração avançada)
# ============================================================

class SR7265LockIn:
    def __init__(self):
        self.inst = None
        self.sensitivity_index = None  # armazena último índice de sensibilidade usado

    def conectar(self, endereco="GPIB0::12::INSTR"):
        if SIMULATE:
            print("Lock-in (simulado) conectado.")
        else:
            import pyvisa
            rm = pyvisa.ResourceManager()
            self.inst = rm.open_resource(endereco)
            # Verifica identificação
            idn = self.inst.query("*IDN?")
            print(f"Conectado: {idn}")

    def configurar(self,
                   modo_referencia='INT',      # 'INT' ou 'EXT'
                   freq_ref=None,              # Hz (se interna)
                   harm=1,                      # harmônico
                   modo_sinal='SIGNAL_RECOVERY', # 'SIGNAL_RECOVERY' ou 'VECTOR_VOLTMETER'
                   entrada='VOLTAGE_A',         # ver tabela VMODE
                   acoplamento='AC',            # 'AC' ou 'DC'
                   dispositivo='FET',           # 'FET' ou 'BIPOLAR'
                   float_ground='FLOAT',        # 'FLOAT' ou 'GROUND'
                   line_filter_off=True,        # desliga filtro de linha
                   auto_ac_gain=True):          # True = automático, False = manual
        """
        Configura o lock-in com os parâmetros desejados.
        """
        if SIMULATE:
            print(f"Lock-in configurado (modo {modo_referencia}, harm={harm})")
            return

        # Modo de referência
        if modo_referencia == 'INT':
            self.inst.write("IE 0")
            if freq_ref is not None:
                # Comando OF em ponto flutuante: OF. <freq_Hz>
                self.inst.write(f"OF. {freq_ref}")
        elif modo_referencia == 'EXT':
            # Usa entrada analógica frontal (REF IN) - pode ser alterado para TTL se necessário
            self.inst.write("IE 2")
        else:
            raise ValueError("modo_referencia deve ser 'INT' ou 'EXT'")

        # Harmônico (em ponto flutuante ou inteiro)
        self.inst.write(f"REFN {harm}")

        # Modo Signal Recovery vs Vector Voltmeter
        # 0 = Signal Recovery, 1 = Vector Voltmeter
        if modo_sinal == 'SIGNAL_RECOVERY':
            self.inst.write("RANGE 0")
        else:
            self.inst.write("RANGE 1")

        # Configuração da entrada de sinal (VMODE)
        # 1 = A only, 2 = -B only, 3 = A-B differential
        mapa_vmode = {
            'VOLTAGE_A': 1,
            'VOLTAGE_MINUS_B': 2,
            'VOLTAGE_A_MINUS_B': 3
        }
        if entrada in mapa_vmode:
            self.inst.write(f"VMODE {mapa_vmode[entrada]}")
        else:
            raise ValueError("entrada inválida")

        # Acoplamento (CP)
        # 0 = AC, 1 = DC
        self.inst.write(f"CP {0 if acoplamento=='AC' else 1}")

        # Dispositivo de entrada (FET)
        # 1 = FET, 0 = Bipolar
        self.inst.write(f"FET {1 if dispositivo=='FET' else 0}")

        # Float/Ground (FLOAT)
        # 1 = Float, 0 = Ground
        self.inst.write(f"FLOAT {1 if float_ground=='FLOAT' else 0}")

        # Filtro de linha (LF) – desligado por padrão
        if line_filter_off:
            self.inst.write("LF 0 0")  # dois parâmetros: n1=0 (off), n2=0 (60 Hz, irrelevante)

        # Controle automático de AC Gain (AUTOMATIC)
        # 1 = automático, 0 = manual
        self.inst.write(f"AUTOMATIC {1 if auto_ac_gain else 0}")

        # Define constante de tempo (TC) em ponto flutuante (segundos)
        self.inst.write(f"TC. {TAU}")

        # NOTA: sensibilidade será ajustada dinamicamente durante a varredura

    def auto_sensitivity(self):
        """
        Executa Auto-Sensitivity (AS) para ajustar a sensibilidade.
        Retorna o índice da nova sensibilidade (ou None se simulação).
        """
        if SIMULATE:
            return None
        self.inst.write("AS")
        # Aguarda um pouco para a operação completar
        time.sleep(TAU * 3)
        # Lê a sensibilidade atual (SEN) para saber o índice
        resp = self.inst.query("SEN")
        self.sensitivity_index = int(resp)
        return self.sensitivity_index

    def ler_XY(self, wavelength=None):
        """
        Lê os valores X e Y do lock-in.
        Se em simulação, gera um espectro gaussiano com ruído.
        """
        if SIMULATE:
            # Simulação de espectro de fluorescência/absorção
            peak = 550
            width = 30
            amplitude = 1e-3

            signal = amplitude * np.exp(-((wavelength - peak)**2) / (2*width**2))
            noise = np.random.normal(0, amplitude*0.05)

            x = signal + noise
            y = noise * 0.3
            return x, y
        else:
            # Usa o comando "XY." que retorna floats em volts (ou amps)
            resp = self.inst.query("XY.")
            x, y = map(float, resp.split(","))
            return x, y

    def verificar_status(self):
        """
        Consulta o status byte (ST) e retorna um dicionário com indicadores de erro.
        """
        if SIMULATE:
            return {'overload': False, 'unlock': False}
        status = int(self.inst.query("ST"))
        overload = bool(status & 0x10)  # bit 4
        unlock   = bool(status & 0x08)  # bit 3
        return {'overload': overload, 'unlock': unlock}

    def fechar(self):
        if not SIMULATE:
            self.inst.close()
        print("Lock-in fechado.")

# ============================================================
# EXECUÇÃO DA VARREDURA
# ============================================================

# Instancia os instrumentos
mono = BenthamMonochromator()
lockin = SR7265LockIn()

# Inicializa
mono.inicializar()
lockin.conectar()

# Configura o lock-in com os parâmetros desejados para o experimento
lockin.configurar(
    modo_referencia='INT',          # usaremos o oscilador interno para modular a fonte
    freq_ref=1000.0,                # 1 kHz
    harm=1,
    modo_sinal='SIGNAL_RECOVERY',
    entrada='VOLTAGE_A',
    acoplamento='AC',
    dispositivo='FET',
    float_ground='FLOAT',
    line_filter_off=True,
    auto_ac_gain=True
)

# Aguarda estabilização inicial
time.sleep(TAU * WAIT_FACTOR)

dados = []
print("Iniciando varredura...\n")

try:
    for wl in range(LAMBDA_START, LAMBDA_END + 1, STEP):
        # Move monocromador (já com correção de backlash)
        wl_real = mono.mover_para(wl)

        # Espera o sistema estabilizar (5x constante de tempo)
        time.sleep(TAU * WAIT_FACTOR)

        # Verifica status do lock-in antes da leitura
        status = lockin.verificar_status()
        if status['overload']:
            print(f"Aviso: overload detectado em {wl_real} nm. Ajustando sensibilidade...")
            lockin.auto_sensitivity()
            time.sleep(TAU * WAIT_FACTOR)  # espera após ajuste

        if status['unlock']:
            print(f"Erro: referência destravada em {wl_real} nm. Pulando ponto.")
            # Poderia tentar religar, mas simplificamos pulando
            continue

        # Lê X e Y
        x, y = lockin.ler_XY(wavelength=wl_real)
        r = math.sqrt(x**2 + y**2)

        print(f"{wl_real:.1f} nm  |  X = {x:.3e}  Y = {y:.3e}  R = {r:.3e}")

        dados.append([wl_real, x, y, r])

finally:
    mono.fechar()
    lockin.fechar()

# ============================================================
# ORGANIZAÇÃO DOS DADOS
# ============================================================

df = pd.DataFrame(dados, columns=["Wavelength (nm)", "X (V)", "Y (V)", "R (V)"])
df.to_csv("espectro_final.csv", index=False)
print("\nArquivo salvo: espectro_final.csv")

# ============================================================
# GRÁFICO
# ============================================================

plt.figure(figsize=(10,6))
plt.plot(df["Wavelength (nm)"], df["R (V)"], 'b-', label='R')
plt.plot(df["Wavelength (nm)"], df["X (V)"], 'r--', alpha=0.5, label='X')
plt.plot(df["Wavelength (nm)"], df["Y (V)"], 'g--', alpha=0.5, label='Y')
plt.xlabel("Wavelength (nm)")
plt.ylabel("Amplitude (V)")
plt.title("Espectro Medido")
plt.legend()
plt.grid(True)
plt.show()

